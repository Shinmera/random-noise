(in-package #:org.shirakumo.random-noise)

(let ((gradients (coerce '(1f0 -1f0) '(simple-array single-float (*)))))
  (declare (type (simple-array single-float (2)) gradients))
  (define-noise-function perlin-noise/1d (point deriv)
    (let* ((i0 (the fixnum (floor (vx point))))
           (t0 (- (vx point) i0))
           (t1 (- t0 1))
           (i0 (logand i0 255))
           (i1 (1+ i0))
           (g0 (aref gradients (logand (noise i0) 1)))
           (g1 (aref gradients (logand (noise i1) 1)))
           (v0 (* g0 t0))
           (v1 (* g1 t1))
           (dt (smooth-dt t0))
           (tt (smooth t0))
           (a v0)
           (b (- v1 v0))
           (da g0)
           (db (- g1 g0)))
      (vsetf deriv (* 2 (+ da (* db tt) (* b dt))) 0 0)
      (* 2 (+ a (* b tt))))))

(with-lut gradient ((nvunit (vec2 +1 +0))
                    (nvunit (vec2 -1 +0))
                    (nvunit (vec2 +0 +1))
                    (nvunit (vec2 +0 -1))
                    (nvunit (vec2 +1 +1))
                    (nvunit (vec2 -1 +1))
                    (nvunit (vec2 +1 -1))
                    (nvunit (vec2 -1 -1)))
  (define-noise-function perlin-noise/2d (point deriv)
    (flet ((dot (v x y)
             (+ (* (vx v) x) (* (vy v) y))))
      (declare (inline dot))
      (let* ((ix0 (the fixnum (floor (vx point))))
             (iy0 (the fixnum (floor (vy point))))
             (tx0 (- (vx point) ix0))
             (ty0 (- (vy point) iy0))
             (tx1 (- tx0 1))
             (ty1 (- ty0 1))
             (ix0 (logand ix0 255))
             (iy0 (logand iy0 255))
             (ix1 (1+ ix0))
             (iy1 (1+ iy0))
             (h0 (noise ix0))
             (h1 (noise ix1))
             (g00 (the vec2 (gradient (noise (+ h0 iy0)))))
             (g10 (the vec2 (gradient (noise (+ h1 iy0)))))
             (g01 (the vec2 (gradient (noise (+ h0 iy1)))))
             (g11 (the vec2 (gradient (noise (+ h1 iy1)))))
             (v00 (dot g00 tx0 ty0))
             (v10 (dot g10 tx1 ty0))
             (v01 (dot g01 tx0 ty1))
             (v11 (dot g11 tx1 ty1))
             (dtx (smooth-dt tx0))
             (dty (smooth-dt ty0))
             (tx (smooth tx0))
             (ty (smooth ty0))
             (a v00)
             (b (- v10 v00))
             (c (- v01 v00))
             (d (+ (- v11 v01 v10) v00))
             (da g00)
             (db (v- g10 g00))
             (dc (v- g01 g00))
             (dd (nv+ (v- g11 g01 g10) g00)))
        (v<- deriv da)
        (nv+* deriv db tx)
        (nv+* deriv dc ty)
        (nv+* deriv dd (* tx ty))
        (incf (vx deriv) (* (+ b (* d ty)) dtx))
        (incf (vy deriv) (* (+ c (* d tx)) dty))
        (setf (vz deriv) 0f0)
        (* (float (sqrt 2) 0f0)
           (+ a (* b tx) (* (+ c (* d tx)) ty)))))))

(with-lut gradient ((nvunit (vec3  1  1  0))
                    (nvunit (vec3 -1  1  0))
                    (nvunit (vec3  1 -1  0))
                    (nvunit (vec3 -1 -1  0))
                    (nvunit (vec3  1  0  1))
                    (nvunit (vec3 -1  0  1))
                    (nvunit (vec3  1  0 -1))
                    (nvunit (vec3 -1  0 -1))
                    (nvunit (vec3  0  1  1))
                    (nvunit (vec3  0 -1  1))
                    (nvunit (vec3  0  1 -1))
                    (nvunit (vec3  0 -1 -1))
                    (nvunit (vec3  1  1  0))
                    (nvunit (vec3 -1  1  0))
                    (nvunit (vec3  0 -1  1))
                    (nvunit (vec3  0 -1 -1)))
  (define-noise-function perlin-noise/3d (point deriv)
    (flet ((dot (v x y z)
             (+ (* (vx v) x) (* (vy v) y) (* (vz v) z))))
      (declare (inline dot))
      (let* ((ix0 (the fixnum (floor (vx point))))
             (iy0 (the fixnum (floor (vy point))))
             (iz0 (the fixnum (floor (vz point))))
             (tx0 (- (vx point) ix0))
             (ty0 (- (vy point) iy0))
             (tz0 (- (vz point) iz0))
             (tx1 (- tx0 1))
             (ty1 (- ty0 1))
             (tz1 (- tz0 1))
             (ix0 (logand ix0 255))
             (iy0 (logand iy0 255))
             (iz0 (logand iz0 255))
             (ix1 (1+ ix0))
             (iy1 (1+ iy0))
             (iz1 (1+ iz0))
             (h0 (noise ix0))
             (h1 (noise ix1))
             (h00 (noise (+ h0 iy0)))
             (h10 (noise (+ h1 iy0)))
             (h01 (noise (+ h0 iy1)))
             (h11 (noise (+ h1 iy1)))
             (g000 (the vec3 (gradient (noise (+ h00 iz0)))))
             (g100 (the vec3 (gradient (noise (+ h10 iz0)))))
             (g010 (the vec3 (gradient (noise (+ h01 iz0)))))
             (g110 (the vec3 (gradient (noise (+ h11 iz0)))))
             (g001 (the vec3 (gradient (noise (+ h00 iz1)))))
             (g101 (the vec3 (gradient (noise (+ h10 iz1)))))
             (g011 (the vec3 (gradient (noise (+ h01 iz1)))))
             (g111 (the vec3 (gradient (noise (+ h11 iz1)))))
             (v000 (dot g000 tx0 ty0 tz0))
             (v100 (dot g100 tx1 ty0 tz0))
             (v010 (dot g010 tx0 ty1 tz0))
             (v110 (dot g110 tx1 ty1 tz0))
             (v001 (dot g000 tx0 ty0 tz1))
             (v101 (dot g100 tx1 ty0 tz1))
             (v011 (dot g010 tx0 ty1 tz1))
             (v111 (dot g110 tx1 ty1 tz1))
             (dtx (smooth-dt tx0))
             (dty (smooth-dt ty0))
             (dtz (smooth-dt tz0))
             (tx (smooth tx0))
             (ty (smooth ty0))
             (tz (smooth tz0))
             (a v000)
             (b (- v100 v000))
             (c (- v010 v000))
             (d (- v001 v000))
             (e (+ (- v110 v010 v100) v000))
             (f (+ (- v101 v001 v100) v000))
             (g (+ (- v011 v001 v010) v000))
             (h (+ (- v111 v011 v101 v110 v000) v001 v010 v100))
             (da g000)
             (db (v- g100 g000))
             (dc (v- g010 g000))
             (dd (v- g001 g000))
             (de (nv+ (v- g110 g010 g100) g000))
             (df (nv+ (v- g101 g001 g100) g000))
             (dg (nv+ (v- g011 g001 g010) g000))
             (dh (nv+ (v- g111 g011 g101 g110 g000) g001 g010 g100)))
        (v<- deriv da)
        (nv+* deriv db tx)
        (nv+* deriv dc ty)
        (nv+* deriv de (* tx ty))
        (nv+* deriv dd tz)
        (nv+* deriv df (* tx tz))
        (nv+* deriv dg (* ty tz))
        (nv+* deriv dh (* tx ty tz))
        (incf (vx deriv) (* (+ b (* e ty) (* (+ f (* h ty)) tz)) dtx))
        (incf (vy deriv) (* (+ c (* e tx) (* (+ g (* h tx)) tz)) dty))
        (setf (vz deriv) (* (+ d (* f tx) (* (+ g (* h tx)) ty)) dtz))
        (+ a (* b tx) (* (+ c (* e tx)) ty) (* (+ d (* f tx) (* (+ g (* h tx)) ty)) tz))))))

(define-noise-entry-function perlin-noise
  (vec3 perlin-noise/3d)
  (vec2 perlin-noise/2d)
  (float perlin-noise/1d))
